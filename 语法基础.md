let 声明变量关键字

数组必须类型相同

元组类型可以不同

元组（）

数组[ ]

Println {}不能写表达式

官方推荐 snake case规范风格 小写并使用下划线分分割单词

const推荐大写 必须显式定义类型



if {}else{}

println！(" ") 没括号 字符串双引号 

if是表达式  可以在let语句右边使用 且必须要有ifelse

![image-20241002210009348](/Users/shushu/Library/Application Support/typora-user-images/image-20241002210009348.png)

![image-20241002210203905](/Users/shushu/Library/Application Support/typora-user-images/image-20241002210203905.png)

把分号去掉 就返回最后那个



loop会一遍又一遍执行 continue break 

![image-20241002210625588](/Users/shushu/Library/Application Support/typora-user-images/image-20241002210625588.png)

![image-20241002210825719](/Users/shushu/Library/Application Support/typora-user-images/image-20241002210825719.png)

![image-20241002214958606](/Users/shushu/Library/Application Support/typora-user-images/image-20241002214958606.png)

 // 创建可变引用 &mut a

不可变引用&a

as 显示式转换



在rust中 &str是字符串切片 指向一段不可变的静态内存

string是在堆上分配的  需要把&str转换为string

把string变成str 就加个&



unwrap是option和result类型的方法 尝试提取option中的值



## Error

```rust
#result是一个枚举类型
result<T，E>
```

```rust
pub fn total_cost(item_quantity: &str) -> Result<i32, ParseIntError> {
    let processing_fee = 1;
    let cost_per_item = 5;
    let qty = item_quantity.parse::<i32>()?;
    Ok(qty * cost_per_item + processing_fee)
}
#这个？ rust中的parse方法不一定解析一定会成功
而用unwrap解包得一定成功
```

```rust
#impl 用来定义一个类型的具体方法或实现
```

```rust
Box<dyn error::Error> 是 Rust 标准库中的一种 动态分配的错误类型，
error::Error 是 Rust 标准库中的一个 trait，定义了通用的错误接口。任何实现了 Error trait 的类型都可以作为 Rust 的标准错误类型。
trait:
```

```rust
let x: i64 = s.parse().map_err(ParsePosNonzeroError::from_parseint)?;
##? 还是这个？号 的问题 他怎么知道我要判断是哪种数据类型
```

```rust
# T U 都表示泛型

```

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is '{}'", result);
}
##这里为什么会有生命周期的问题
```

```rust
#随地创建独立的作用域 {}
```

```rust
Rust 中的 # 并不是注释符号，而是用于 编译指令（attributes），它告诉编译器或测试框架一些元信息，比如是否应该执行测试、检查是否会触发 panic，等等。
```



```rust
// Step 1.
// Complete the `capitalize_first` function.
// "hello" -> "Hello"
pub fn capitalize_first(input: &str) -> String {
    let mut c = input.chars();
    match c.next() {
        None => String::new(),
        Some(first) => first.to_uppercase().collect::<String>()+c.as_str(),
    }
}

// Step 2.
// Apply the `capitalize_first` function to a slice of string slices.
// Return a vector of strings.
// ["hello", "world"] -> ["Hello", "World"]
pub fn capitalize_words_vector(words: &[&str]) -> Vec<String> {
    words.iter().map(|&word| capitalize_first(word)).collect()
}

// Step 3.
// Apply the `capitalize_first` function again to a slice of string slices.
// Return a single string.
// ["hello", " ", "world"] -> "Hello World"
pub fn capitalize_words_string(words: &[&str]) -> String {
    words.iter().map(|&word| capitalize_first(word)).collect::<String>()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_success() {
        assert_eq!(capitalize_first("hello"), "Hello");
    }

    #[test]
    fn test_empty() {
        assert_eq!(capitalize_first(""), "");
    }

    #[test]
    fn test_iterate_string_vec() {
        let words = vec!["hello", "world"];
        assert_eq!(capitalize_words_vector(&words), ["Hello", "World"]);
    }

    #[test]
    fn test_iterate_into_string() {
        let words = vec!["hello", " ", "world"];
        assert_eq!(capitalize_words_string(&words), "Hello World");
    }
}

```



* isize和usize在不同平台有所区别

* 单位类型 () 空白类型 表示返回空 即不返回任何值

* 数组和元组 

  * 数组必须同类型  let a：[1,2,3]  数组这样可以计算很快 放在**栈上**空间 自动推导大小和长度 在栈上分配的已知固定大小的单个内存块  不能插入删除（固定空间）
  * 元组  tuple   let v:(1,a,3.4)

* 函数采取snake_case规范风格

* const要用upper_case

* ```rust
  if {} else {}
  ```

* ```rust
  let number = if condition {5} else {6}  //函数式编程 表达式语法  Rust 是一种强调表达式的语言，几乎所有的东西都是表达式。
  ```

* ```rust
  loop{ } 
  //会一直循环 直到看到break     
  let mut counter =0;
  let result = loop{ counter + = 1;
    if count ==10{
      break couter*2 }};
  //赋值了
  #循环标签 
  ‘q：loop{
    loop{
      break 'q;
    }
  }//跳出最外层循环 只能在循环里写标签
  ```

* ```
  let b = [1,2,3,4]
  for a in b{
  }
  for a in 1..=10{}//从一到十
  ```

* ```
  while condition {
  }
  ```

* ```rust
  //所有权
  值在任何时候有且只有一个所有者 当所有者离开作用域 值被丢弃
  {
    a
  } 括号外无法访问a的值
  //？？ 不清楚底层是怎么实现的
  let x =123;
  let y = x;//x将被丢弃 
  为了简便 此时会发生x的值复制 复制给y 自动复制 此时x其实不会被丢弃 即所有权不会被转移 但对于较复杂的类型就会先前变量被丢弃 但如果后者先消亡 先前变量在后者消亡周期内依旧持有该值 即所有权转移
  //函数参数
  trait(copy,clone) 复制就不会夺走前面的所有权
  即对于简单类型的数据 rust对于’=‘已经实现了复制 而复杂数据没有 ’=‘会转移所有权
  多线程会安全一些
  ```

* 如果定义一个同名变量 第一个变量会被第二个变量隐藏 （shadowing）

* ```rust
  to_string 
  String
  &str
  
  ```

* ```rust
  //引用与借用
  引用可以由编译器管理 指针不行 它确保有值
  创建引用即为借用
  ```

* 
